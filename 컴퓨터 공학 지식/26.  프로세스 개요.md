# 26. ****프로세스 개요****

실행 중인 프로그램, 프로세스 

프로그램은 실행되기 전까지 보조기억 장치에 있는 데이터 덩어리일 뿐이다.

보조기억 장치에 저장된 프로그램을 실행해 메모리에 적재하고 실행하는 순간 해당 프로그램은 프로세스가 된다

이런 과정을 프로세스를 생성한다고 한다. 

### 프로세스 직접 확인해 보기

- 윈도우

![Untitled (6)](https://user-images.githubusercontent.com/79884004/232504093-016accc0-54e1-4069-bb69-b8cfb7c1b812.png)

- 리눅스, macOS [ps 명령어]
    
    <img width="555" alt="Untitled (7)" src="https://user-images.githubusercontent.com/79884004/232504087-ea5e6648-b80d-4d69-927b-bedadf55f122.png">
    
- 포그라운드 프로세스 (foreground process)
    - 사용자가 볼 수 있는 공간에서 실행되는 프로세스
- 백그라운드 프로세스 (background process)
    - 사용자가 볼 수 없는 공간에서 실행되는 프로세스
    - 사용자와 상호작용이 가능한 백그라운드 프로세스
    - 사용자와 상호작용X, 정해지 일만 수행하는 프로세스 
    데몬 (Daemon), 서비스 (Service)
        
        ![Untitled (8)](https://user-images.githubusercontent.com/79884004/232504082-478b53b6-8935-48e1-90f2-ff0e61656211.png)
        
    

### 프로세스 제어 블록 (PCB)

모든 프로세스는 실행을 위해 CPU가 필요하다. 하지만 CPU 자원은 한정되어 있다.

- 프로세스들은 돌아가며 한정된 시간 만큼 CPU 이용
    - 자신의 차례에 정해진 시간만큼 CPU이용
    - 타임아웃 인터럽트가 발생하면 차례 양보
- 빠르게 번갈아 면서 수행되는 프로세스들을 관리하기 위한 자료구조
    - 프로세스 관련 정보를 저장하는 자료 구조
    - 상품에 달린 태그와 같은 정보
    - 프로세스 생성 시 커널 영역에 생성, 종료 시 폐기
- PCB에 담기는 대표적인 정보
    - 프로세스 ID = (PID)
        - 특정 프로세스를 식별하기 위해 부여하는 고유한 번호
    - 레지스터 값
        - PCB에 왜 레지스터 값이 담기나?
        프로세스는 자신의 실행 차례가 되면 이전까지 사용한 레지스터 중간 값을 모두 복원 why?  CPU에서 이용했던 레지스터 값들을 알고 있어야 차례가 돌아 왔을 때 실행을 재게 하기 위해→ 실행 재게
        - 프로그램 카운터(다음번에 실행할 메모리 주소 담김), 스택 포인터
    - 프로세스 상태
        - 입출력 장치를 사용하기 위해 대기 상태, CPU 사용하기 위해 대기 상태, CPU 이용 상태…
    - CPU 스케줄링 정보
    - 메모리 정보
        - 프로세스가 저장되어 있는 주소에 대한 정보
        - 페이지 테이블 정보 (메모리 주소를 알 수 있는 정보)
    - 사용한 파일과 입출력 장치 정보
        - 할당된 입출력 장치, 사용 중인 파일 정보

운영체제는 커널 영역에 적재된 PCB를 보고 프로세스를 관리한다. 

### 문맥 교환 (Context Switch)

질문 

한 프로세스에서 다른 프로세스로 **실행 순서**가 넘어가면?

- 기존에 실행 되던 프로세스는 지금까지의 **중간 정보**를 백업한다.
    - 프로그램 카운터 등 각종 레지스터 값, 메모리정보, 열었던 파일, 사용한 입출력 장치 등
    - 이러한 중간 정보 == 문맥 (context)
    - 다음 차례가 왔을 때 실행을 재개하기 위한 정보
    - “실행 문맥을 백업해두면 언제든 해당 프로세스의 실행을 재개할 수 있다.”
- 뒤이어 실행할 프로세스 B의 문맥을 복구
    - 자연스럽게 실행 중인 프로세스가 바뀐다.

자 그래서 문맥교환이란?

기존의 실행 중인 프로세스 문맥을 백업하고 

새로운 프로세스 실행을 위해 문맥을 복구하는 과정이다. 

여러 프로세스가 끊임없이 빠르게 번갈아 실행되는 원리이다. 

<img width="277" alt="Untitled (9)" src="https://user-images.githubusercontent.com/79884004/232504076-6fe91264-2473-4610-93f0-c95b039c76dc.png">

### 프로세스의 메모리 영역

사용자 영역 - 스택 영역, 힙 영역, 데이터 영역, 코드 영역 (텍스트 영역)

- 코드 영역 (텍스트 영역)
    - 실행할 수 있는 코드, 기계어로 이루어진 명령어 저장
    - 데이터가 아닌 CPU가 실행할 명령어가 담기기에 쓰기가 금지된 영역 (read-only)
- 데이터 영역
    - 잠깐 썼다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터 저장
    - ex. 전역 변수

코드 영역, 데이터 영역  - 정적할당 영역

- 힙 영역
    - 프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장공간
    - 힙 영역에 메모리 할당 시 해제도 해줘야한다. → 가비지 컬렉션
    - 메모리 해제를 해주지 않으면 메모리 공간 차지로 메모리 낭비가 일어난다. → 메모리 누수
- 스택 영역
    - 데이터가 일시적으로 저장되는 공간
    - 데이터 영역에 담기는 값과 달리 한시적으로 쓸 값들이 저장되는 공간
    - ex. 매개 변수, 지역 변수

힙, 스택 영역 - 동적 할당 영역 

- 힙 영역과 스택 영역의 크기는 가변적
    - 힙 영역은 낮은 주소 → 높은 주소로 할당
    - 스택 영역 높은 주소 → 낮은 주소 할당
    - 같은 방향으로 커지면 공간에 한계가 있기 때문에 서로 반대 방향으로 주소를 할당한다.
