## 명령어의 구조와 주소 지정 방식



### 명령어의 구조

연산 코드와 오퍼랜드로 구성

수행할 연산(연산 코드) -연산에 사용될 데이터 혹은 연산에 사용될 데이터가 저장된 위치 (오퍼랜드)

기계어, 어셈블리어는 명렁어이다.

![Untitled (2)](https://user-images.githubusercontent.com/79884004/226892343-96580452-5a78-4555-aac1-e248f30bddf4.png)

붉은 글씨 연산코드 검은 글씨는 오퍼랜드이다.

### 오퍼랜드

연산에 사용될 데이터 

**연산에 사용될 데이터가 저장된 위치** **(주소필드)  ←** 더 자주 사용됨

![Untitled (3)](https://user-images.githubusercontent.com/79884004/226892359-996d27b9-22d3-4d3d-a0e5-6728e282e07e.png)


### 연산코드

연산 코드의 종류 & 생김새는 CPU 마다 다르다.

1. 데이터 전송
    1. MOVE
    2. STORE
    3. LOAD(FETCH)
    4. PUSH
    5. POP
2. 산술/논리 연산
    1. ADD / SUBTRACT / MULTIPLY / DIVIDE 
    2. INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 빼라 
    3. AND / OR / NOT:AND / OR / NOT 
    4. COMPARE: 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라
3. 제어 흐름 변경
    1. JUMP: 특정 주소로 실행 순서를 옮겨라 
    2. CONDITIONAL JUMP: 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라 
    3. HALT: 프로그램의 실행을 멈춰라
    4. CALL: 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
    5. RETURN: CALL을 호출할 때 저장했던 주소로 돌아가라 
4. 입출력 제어
    1. READ(INPUT) : 읽기
    2. WRITE(OUTPUT) : 쓰기
    3. START IO : 시작
    4. TEST IO : 상태 확인

### 명령어 주소 지정 방식

- 왜 굳이 저장된 위치를 쓰는걸까?
    
    주소 명령에서 표현할 수 있는 데이터 크기가 정해져 있기 때문이다.
    
    EX.  명령어 크기 16비트 연산 코드 4비트 주소 명령어 오퍼랜드 2개 일때 
    
    각각의 오펀랜드는 6비트씩 가진다. 6비트로 데이터를 표현하는 방법은 2의 6승 64종류로 작다.
    
    오퍼랜드 종류가 많아지면 더 줄어들기 때문에 저장된 위치를 사용한다. 
    

- 레지스터에 연산의 사용될 데이터를 저장할 수도 있다.
    
    레지스터에 데이터를 저장하는 이유도 마찬가지로 오퍼랜드는 작기 때문이다. 
    

- 유효 주소 (effective address)?
    - 연산에 사용할 데이터가 저장된 위치

- 명령어 주소 지정 방식(addressing modes)
    - 연산에 사용할 데이터가 저장된 위치를 찾는 방법
    - **유효 주소를 찾는 방법**
    - 다양한 명령어 주소 지정 방식들

자 요기 까지보면 

오퍼랜드 필드에는 레지스터, 메모리 주소, 연산 코드의 사용될 데이터가 명시 될 수 있다.

CPU는 연산에 사용될 데이터를 찾아서 실행해야 한다.

###  즉시 주소 지정 방식 (immediate addressing mode)
    - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
    - 가장 간단한 형태의 주소 지정 방식
    - 연산에 사용할 데이터의 크기가 작아질 수 있지만, 빠름
    - 연산에 사용할 데이터 크기 제한
    
    연산코드 - 연산에 사용할 데이터
    
### 직접 주소 지정 방식 (direct addressing mode)
    - 오퍼랜드 필드에 유효 주소 직접적으로 명시
    - 유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어듦
    - 배열(Array)과 같은 자료 구조에서 인덱스를 사용하여 해당 위치에 직접 데이터를 저장하는 방식으로 메모리 주소에 직접 접근
    
    연산코드 - 유효주소 →메모리(연산에 사용할 데이터)
    
### 간접 주소 지정 방식(indirect addressing mode)
    - 오퍼랜드 필드에 유효 주소의 주소를 명시
    - 앞선 주소 지정 방식들에 비해 속도가 느림
    - 유효 주소를 충분히 표현 가능
    
    연산코드 | 유효 주소의 주소 |  메모리 (유효 주소 → 연산에 사용할 데이터)
    
    CPU가 메모리를 찾아 다니는 시간은 매우 느리다.
    
    메모리 접근을 최소화 하는 것이 속도면에서 좋다.
    
### 레지스터 주소 지정 방식(register addressing mode)
    - 연산에 사용할 데이터가 저장된 레지스터 명시
    - 메모리에 접근하는 속도보다 레지스터에 접근 하는 것이 빠름
    
    CPU가 메모리에 접근 하는 속도보다 레지스터가 메모리에 접근하는 속도가 훨씬 빠르다.
    
    메모리는  CPU밖에 있고 레지스터는 CPU안에 있다.
    
    연산 코드 - 유효 주소를 저장한 레지스터 → 레지스터(유효주소) → 메모리(연산에 사용할 데이터)**
