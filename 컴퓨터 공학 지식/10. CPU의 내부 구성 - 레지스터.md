# CPU의 내부 구성 - 레지스터 

### 레지스터

- CPU 내부의 작은 임시저장장치
- 프로그램 속 명령어 & 데이터는 실행 전후로 레지스터에 저장
- ALU와 제저장치는 프로그래머가 직접적으로 다룰 일은 레지스터보다 적다.
- 시스템 개발자 인베디드 해킹 레지스터 관찰 필요
- CPU 내부에 다양한 레지스터들이 있고, 각기 다른 역할을 가진다.

## 반드시 알아야할 레지스터

### 1. 프로그램 카운터

메모리에서 가져올 명령어의 주소 (메모리에서 읽어 들일 명령어의 주소)

instruction pointer 명려어 포인터 라고 불는 CPU도 있다.

### 2. 명령어 레지스터

해석할 명령어 (방금 메모리에서 읽어 들인 명령어) 

→ 제어장치가 받아 들여 해석하고 제어신호를 보낸다.

### 3. 메모리 주소 레지스터

메모리의 주소를 저장

CPU가 읽어 들이고자 하는 주소를 주소 버스로 내보낼 때 거치는 레지스터

CPU가 

### 4. 메모리 버퍼 레지스터

메모리와 주고받을 값 (데이터와 명령어)

CPU가 정보를 **데이터 버스로 주고받을 때** 거치는 레지스터

![Untitled (4)](https://user-images.githubusercontent.com/79884004/227758467-db58eb14-773e-4bac-9a71-098ab714cb19.png)

**프로그램 카운터** 1000번지는 1101를 실행할거야

→ 프로그램 카운터에 저장되어 있는 다음으로 읽어드릴 며령어 주소값은 **메모리 주소 레지스터**로 복사된다.

→ 메모리 읽기 신호와 함께 몇 번지 주소를 읽고 싶은지 쏴준다.

→ 메모리는 1000번지 저장된 값을 **메모리 버퍼 레지스터**로 데이터버스를 통해 전달

→ 프로그램 카운터 1증가

→ 메모리 1000번지 있던 1101데이터를 제어장치를 통해 해석하기 위해 **명령어 레지스터**를 복사한다.

### 순차적인 실행 흐름이 끊기는 경우

- 특정 메모리 주소로 실행 흐름을 이동하는 명령어 실행 시
    
    JUMP, CONDITIONAL JUMP, CALL, RET
    
- 인터럽트 발생 등

### 5. 플래그 레지스터

연산 결과 또는 CPU상태에 대한 부가적인 정보

플래그 레지스터를 읽으면 현재 CPU가 어떤 연사을 하고 있었는지 CPU상태는 어떤지 직간적으로 파악 가능

### 6. 범용 레지스터

다양하고 일반적인 상황에서 자유롭게 사용
주소, 명령어, 데이터도 담을수 있고 여러개가 있다.

### 7. 스택 포인터

스택 포인터?  스택의 꼭대기를 가리키는 레지스터 (스택의 현재 용량을 표시)

**스택 주소지정 방식?** 스택과 스택 포인터를 이용한 주소 지정 방식 특별한 주소 지정에 사용

스택 어디있나?   메모리 안에 스택 영역

### 8. 베이스 레지스터

기준 주소 정장 

변위 주소 지정방식이라는 특별한 주소 지정에 사용

**변위 주소 지정방식?** 오퍼랜드 필드의 값(변위)과 CPU의 특정 레지스터의 값을 더하여 유효 주소 얻기

유효주소: 해당 데이터가 저장된 기억장치의 실제주소

연산코드(이런 내용을 수행하라)-레지스터(리 레지스터 값과)-오퍼랜드(이 주소를 더한 곳에 있는 데이터로)

2가지 방법 

1. **상대 주소 지정 방식**: 오퍼랜드 필드의 값과 프로그램 카운터 더하여 유효주소 얻는 방법
2. **베이스 레지스터 주소 지정 방식**: 오퍼랜드 필드의 값과 **베이스 레지스터(기준 주소)** 더하여 유효주소 얻는 방법

